import { get } from './api';
import { getMediaURL } from './api';
import * as locationService from './location';

/**
 * Servicios para manejo de proveedores (talleres y mec√°nicos)
 * Funciones para obtener, filtrar y gestionar proveedores
 */

/**
 * Obtiene proveedores por veh√≠culo espec√≠fico
 * @param {number} vehiculoId - ID del veh√≠culo
 * @returns {Promise<Object>} Objeto con talleres y mec√°nicos
 */
export const getProvidersByVehiculo = async (vehiculoId) => {
  try {
    // Obtener informaci√≥n del veh√≠culo
    const vehicleResponse = await get(`/vehiculos/${vehiculoId}/`);
    if (!vehicleResponse || !vehicleResponse.modelo) {
      console.log(`Veh√≠culo ${vehiculoId} no encontrado o sin modelo`);
      return { talleres: [], mecanicos: [] };
    }

    // Obtener talleres por modelo
    const talleresResponse = await get('/usuarios/talleres/', {
      modelo: vehicleResponse.modelo,
      especialidades: true
    });

    // Obtener mec√°nicos por modelo
    const mecanicosResponse = await get('/usuarios/mecanicos-domicilio/', {
      modelo: vehicleResponse.modelo,
      especialidades: true
    });

    return {
      talleres: talleresResponse.results || talleresResponse || [],
      mecanicos: mecanicosResponse.results || mecanicosResponse || []
    };
  } catch (error) {
    console.error(`Error obteniendo proveedores para veh√≠culo ${vehiculoId}:`, error);
    return { talleres: [], mecanicos: [] };
  }
};

/**
 * Obtiene proveedores filtrados por veh√≠culo y servicios seleccionados
 * @param {number} vehiculoId - ID del veh√≠culo
 * @param {Array<number>} servicioIds - IDs de servicios seleccionados (opcional)
 * @returns {Promise<Object>} Objeto con talleres y mec√°nicos filtrados
 */
export const getProvidersByVehiculoAndService = async (vehiculoId, servicioIds = []) => {
  try {
    if (!vehiculoId) {
      console.log('No se proporcion√≥ ID de veh√≠culo');
      return { talleres: [], mecanicos: [] };
    }

    // Construir par√°metros para la consulta
    // El backend espera servicio_ids[]=1&servicio_ids[]=2 para arrays
    const params = {
      vehiculo_id: vehiculoId
    };

    // Agregar servicio_ids si est√°n presentes
    // Para arrays con corchetes, axios necesita que la clave termine con []
    if (servicioIds && servicioIds.length > 0) {
      // Construir objeto con m√∫ltiples claves servicio_ids[]
      // Axios serializar√° esto correctamente como servicio_ids[]=1&servicio_ids[]=2
      servicioIds.forEach((id, index) => {
        params[`servicio_ids[${index}]`] = id;
      });
    }

    console.log(`üîç Llamando a proveedores_filtrados con:`, params);

    // Llamar a los endpoints de proveedores filtrados
    const talleresResponse = await get(`/usuarios/talleres/proveedores_filtrados/`, params);
    const mecanicosResponse = await get(`/usuarios/mecanicos-domicilio/proveedores_filtrados/`, params);

    return {
      talleres: talleresResponse.talleres || [],
      mecanicos: mecanicosResponse.mecanicos || [],
      filtros_aplicados: {
        marca: talleresResponse.filtros_aplicados?.marca_vehiculo || mecanicosResponse.filtros_aplicados?.marca_vehiculo || null,
        servicios: servicioIds.length > 0 ? servicioIds : 'todos'
      }
    };
  } catch (error) {
    console.error(`‚ùå Error obteniendo proveedores filtrados para veh√≠culo ${vehiculoId}:`, error);
    if (error.response) {
      console.error(`‚ùå Status: ${error.response.status}`);
      console.error(`‚ùå Data:`, error.response.data);
      console.error(`‚ùå URL completa: ${error.config?.baseURL}${error.config?.url}`);
      console.error(`‚ùå Par√°metros:`, error.config?.params);

      // Si es 404, intentar con la URL sin el par√°metro de array
      if (error.response.status === 404 && servicioIds.length > 0) {
        console.log('‚ö†Ô∏è 404 detectado, intentando con formato alternativo de par√°metros...');
        // Intentar con formato diferente para arrays
        const paramsAlt = { vehiculo_id: vehiculoId };
        servicioIds.forEach((id, index) => {
          paramsAlt[`servicio_ids[${index}]`] = id;
        });

        try {
          const talleresResponse = await get(`/usuarios/talleres/proveedores_filtrados/`, paramsAlt);
          const mecanicosResponse = await get(`/usuarios/mecanicos-domicilio/proveedores_filtrados/`, paramsAlt);

          return {
            talleres: talleresResponse.talleres || [],
            mecanicos: mecanicosResponse.mecanicos || [],
            filtros_aplicados: {
              marca: talleresResponse.filtros_aplicados?.marca_vehiculo || mecanicosResponse.filtros_aplicados?.marca_vehiculo || null,
              servicios: servicioIds
            }
          };
        } catch (retryError) {
          console.error('‚ùå Error en reintento:', retryError);
        }
      }
    } else if (error.message) {
      console.error(`‚ùå Error message: ${error.message}`);
    }
    return { talleres: [], mecanicos: [] };
  }
};

/**
 * Calcula la distancia entre dos coordenadas usando la f√≥rmula de Haversine
 * @param {number} lat1 - Latitud del primer punto
 * @param {number} lon1 - Longitud del primer punto
 * @param {number} lat2 - Latitud del segundo punto
 * @param {number} lon2 - Longitud del segundo punto
 * @returns {number} Distancia en kil√≥metros
 */
function calculateDistance(lat1, lon1, lat2, lon2) {
  const R = 6371; // Radio de la Tierra en kil√≥metros
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
    Math.sin(dLon / 2) * Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

/**
 * Normaliza un nombre de comuna para comparaci√≥n
 * Remueve acentos, convierte a min√∫sculas y normaliza espacios
 * @param {string} communeName - Nombre de la comuna
 * @returns {string} Nombre normalizado
 */
function normalizeCommuneName(communeName) {
  if (!communeName || typeof communeName !== 'string') {
    return '';
  }

  // Remover acentos y caracteres especiales
  let normalized = communeName
    .trim()
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '') // Remover diacr√≠ticos
    .replace(/[^a-z0-9\s]/g, '') // Remover caracteres especiales
    .replace(/\s+/g, ' ') // Normalizar espacios m√∫ltiples a uno solo
    .trim();

  return normalized;
}

/**
 * Obtiene talleres para los veh√≠culos del usuario
 * Filtra por marca de veh√≠culo usando el endpoint proveedores_filtrados
 * @param {Array} userVehicles - Lista de veh√≠culos del usuario
 * @returns {Promise<Array>} Lista de talleres compatibles
 */
export const getWorkshopsForUserVehicles = async (userVehicles, signal = null) => {
  try {
    if (!userVehicles || userVehicles.length === 0) {
      return [];
    }

    // Obtener la direcci√≥n principal del usuario para calcular distancias
    const address = await locationService.getMainAddress();
    let coords = null;

    if (address) {
      const addressString = typeof address === 'object' ? address.direccion : address;

      // PRIORIDAD: Usar coordenadas guardadas en la direcci√≥n si est√°n disponibles
      if (typeof address === 'object' && address.ubicacion) {
        // La direcci√≥n puede tener coordenadas en el campo ubicacion (GeoJSON Point)
        if (address.ubicacion.coordinates && Array.isArray(address.ubicacion.coordinates) && address.ubicacion.coordinates.length >= 2) {
          // GeoJSON usa [longitude, latitude]
          coords = {
            latitude: parseFloat(address.ubicacion.coordinates[1]),
            longitude: parseFloat(address.ubicacion.coordinates[0])
          };
          console.log(`‚úÖ Usando coordenadas guardadas de la direcci√≥n (talleres): ${coords.latitude}, ${coords.longitude}`);
        }
      }

      // Si no hay coordenadas guardadas, geocodificar la direcci√≥n
      if (!coords) {
        console.log('üìç No hay coordenadas guardadas, geocodificando direcci√≥n (talleres)...');
        coords = await locationService.geocodeAddress(addressString);
        if (coords) {
          console.log(`‚úÖ Coordenadas obtenidas por geocodificaci√≥n (talleres): ${coords.latitude}, ${coords.longitude}`);
        } else {
          console.warn('‚ö†Ô∏è No se pudieron obtener coordenadas por geocodificaci√≥n (talleres)');
        }
      }
    }

    const allWorkshops = [];
    const workshopIds = new Set();

    // Usar el endpoint proveedores_filtrados que filtra por marca del veh√≠culo
    for (const vehicle of userVehicles) {
      if (vehicle.id) {
        try {
          // Usar el endpoint que filtra por marca del veh√≠culo
          const params = {
            vehiculo_id: vehicle.id
          };

          const response = await get('/usuarios/talleres/proveedores_filtrados/', params);

          // El endpoint devuelve { talleres: [...], total: ..., filtros_aplicados: {...} }
          const workshops = response.talleres || [];

          if (Array.isArray(workshops)) {
            workshops.forEach(workshop => {
              if (!workshopIds.has(workshop.id)) {
                workshopIds.add(workshop.id);
                allWorkshops.push(workshop);
              }
            });
          }
        } catch (error) {
          console.error(`Error obteniendo talleres para veh√≠culo ${vehicle.id}:`, error);
          // Continuar con el siguiente veh√≠culo si hay error
        }
      }
    }

    // Si tenemos coordenadas, calcular y ordenar por distancia
    if (coords && allWorkshops.length > 0) {
      // Calcular distancia para cada taller si no la tienen
      allWorkshops.forEach(workshop => {
        let workshopLat = null;
        let workshopLng = null;

        // Intentar obtener coordenadas desde diferentes fuentes
        if (workshop.direccion_fisica && workshop.direccion_fisica.latitud && workshop.direccion_fisica.longitud) {
          workshopLat = parseFloat(workshop.direccion_fisica.latitud);
          workshopLng = parseFloat(workshop.direccion_fisica.longitud);
        } else if (workshop.ubicacion) {
          // Si tiene ubicaci√≥n GeoDjango
          if (typeof workshop.ubicacion === 'object' && workshop.ubicacion.coordinates) {
            workshopLng = parseFloat(workshop.ubicacion.coordinates[0]);
            workshopLat = parseFloat(workshop.ubicacion.coordinates[1]);
          }
        }

        if (workshopLat && workshopLng && !isNaN(workshopLat) && !isNaN(workshopLng)) {
          // Calcular distancia (Haversine)
          const distance = calculateDistance(
            coords.latitude,
            coords.longitude,
            workshopLat,
            workshopLng
          );

          // Asignar distancia en m√∫ltiples campos para compatibilidad
          workshop.distancia_km = distance;
          workshop.distance = distance; // Campo usado por NearbyTallerCard
          workshop.distancia = distance; // Campo alternativo

          console.log(`üìè Distancia calculada para taller ${workshop.id} (${workshop.nombre}): ${distance.toFixed(2)}km`);
        } else {
          // Si no tiene coordenadas, usar distancia del backend si est√° disponible
          if (workshop.distance !== undefined && workshop.distance !== null) {
            const backendDistance = typeof workshop.distance === 'number' ? workshop.distance : parseFloat(workshop.distance);
            workshop.distancia_km = backendDistance;
            workshop.distance = backendDistance;
            workshop.distancia = backendDistance;
            console.log(`üìè Usando distancia del backend para taller ${workshop.id}: ${backendDistance.toFixed(2)}km`);
          } else {
            console.warn(`‚ö†Ô∏è Taller ${workshop.id} (${workshop.nombre}) no tiene coordenadas ni distancia del backend`);
          }
        }
      });

      // Ordenar por distancia
      allWorkshops.sort((a, b) => {
        const distA = a.distance || a.distancia_km || a.distancia || Infinity;
        const distB = b.distance || b.distancia_km || b.distancia || Infinity;
        return distA - distB;
      });
    }

    return allWorkshops;
  } catch (error) {
    console.error('Error obteniendo talleres para veh√≠culos del usuario:', error);
    return [];
  }
};

/**
 * Obtiene mec√°nicos para los veh√≠culos del usuario
 * Filtra por marca de veh√≠culo, zonas de servicio (comunas) y radio de cobertura
 * @param {Array} userVehicles - Lista de veh√≠culos del usuario
 * @returns {Promise<Array>} Lista de mec√°nicos compatibles
 */
export const getMechanicsForUserVehicles = async (userVehicles, signal = null) => {
  try {
    if (!userVehicles || userVehicles.length === 0) {
      return [];
    }

    // Obtener la direcci√≥n principal del usuario para calcular distancias y obtener comuna
    const address = await locationService.getMainAddress();
    let coords = null;
    let userCommune = null;

    if (address) {
      const addressString = typeof address === 'object' ? address.direccion : address;

      // PRIORIDAD: Usar coordenadas guardadas en la direcci√≥n si est√°n disponibles
      if (typeof address === 'object' && address.ubicacion) {
        // La direcci√≥n puede tener coordenadas en el campo ubicacion (GeoJSON Point)
        if (address.ubicacion.coordinates && Array.isArray(address.ubicacion.coordinates) && address.ubicacion.coordinates.length >= 2) {
          // GeoJSON usa [longitude, latitude]
          coords = {
            latitude: parseFloat(address.ubicacion.coordinates[1]),
            longitude: parseFloat(address.ubicacion.coordinates[0])
          };
          console.log(`‚úÖ Usando coordenadas guardadas de la direcci√≥n: ${coords.latitude}, ${coords.longitude}`);
        }
      }

      // Si no hay coordenadas guardadas, geocodificar la direcci√≥n
      if (!coords) {
        console.log('üìç No hay coordenadas guardadas, geocodificando direcci√≥n...');
        coords = await locationService.geocodeAddress(addressString);
        if (coords) {
          console.log(`‚úÖ Coordenadas obtenidas por geocodificaci√≥n: ${coords.latitude}, ${coords.longitude}`);
        } else {
          console.warn('‚ö†Ô∏è No se pudieron obtener coordenadas por geocodificaci√≥n');
        }
      }

      // PRIORIDAD 1: Intentar extraer comuna directamente del string de direcci√≥n
      // Las direcciones t√≠picamente incluyen la comuna en el formato: "Calle 123, Comuna, Regi√≥n, Chile"
      if (addressString) {
        // Obtener todas las comunas de Chile desde el backend (o usar lista est√°tica)
        // Por ahora, intentar extraer del string usando patrones comunes
        const addressLower = addressString.toLowerCase();

        // Patrones comunes de direcciones chilenas:
        // "Calle, Comuna, Regi√≥n, Chile"
        // "Comuna, Regi√≥n, Chile"
        // Buscar la palabra antes de la regi√≥n o antes de "Chile"

        // Intentar extraer usando el patr√≥n: texto antes de la √∫ltima coma antes de "Chile" o regi√≥n
        const parts = addressString.split(',').map(p => p.trim()).filter(p => p.length > 0);

        // Estructuras comunes de direcciones chilenas:
        // "Calle 123, Comuna, Regi√≥n, Chile"
        // "Calle 123, Comuna, Chile"  
        // "Comuna, Regi√≥n, Chile"
        // "Calle 123, Comuna"

        if (parts.length >= 2) {
          let potentialCommune = null;

          // Buscar la comuna en diferentes posiciones seg√∫n la estructura
          // Normalmente est√° antes de "Chile" o antes de una regi√≥n conocida
          const regions = ['metropolitana', 'valparaiso', 'bio bio', 'araucania', 'los lagos'];
          const lastPart = parts[parts.length - 1].toLowerCase();
          const secondLastPart = parts.length >= 2 ? parts[parts.length - 2].toLowerCase() : '';

          // Si la √∫ltima parte es "Chile" o una regi√≥n conocida, la comuna est√° en la pen√∫ltima
          if (lastPart === 'chile' || regions.some(r => lastPart.includes(r))) {
            if (parts.length >= 3) {
              // Estructura: [Calle, Comuna, Regi√≥n/Chile]
              potentialCommune = parts[parts.length - 2];
            } else if (parts.length === 2) {
              // Estructura: [Comuna, Chile]
              potentialCommune = parts[0];
            }
          } else if (parts.length === 2 && secondLastPart) {
            // Si solo hay 2 partes y la √∫ltima no es Chile, puede ser [Calle, Comuna]
            potentialCommune = parts[1];
          } else if (parts.length >= 3) {
            // Intentar con la pen√∫ltima posici√≥n
            potentialCommune = parts[parts.length - 2];
          }

          if (potentialCommune && potentialCommune.toLowerCase() !== 'chile' && !regions.some(r => potentialCommune.toLowerCase().includes(r))) {
            // Normalizar y verificar que no sea muy largo (comunas t√≠picamente < 30 caracteres)
            // y que no sea un n√∫mero (direcciones)
            const normalized = normalizeCommuneName(potentialCommune);
            const isNumber = /^\d+$/.test(normalized.replace(/\s/g, ''));

            if (normalized.length > 2 && normalized.length < 30 && !isNumber) {
              userCommune = normalized;
              console.log(`üìç Comuna del usuario extra√≠da del string de direcci√≥n: "${potentialCommune}" (normalizada: "${userCommune}")`);
            }
          }
        }

        // Si no se pudo extraer del patr√≥n, buscar comunas conocidas en el string
        if (!userCommune) {
          const commonCommunes = [
            'santiago', 'providencia', 'las condes', '√±u√±oa', 'maipu', 'macul',
            'san miguel', 'la florida', 'puente alto', 'san bernardo', 'cerro navia',
            'recoleta', 'independencia', 'quilicura', 'huechuraba', 'vitacura',
            'san joaquin', 'la granja', 'la pintana', 'el bosque', 'lo espejo',
            'pedro aguirre cerda', 'lo prado', 'estacion central', 'cerro navia',
            'conchali', 'renca', 'penalolen', 'la reina', 'barnechea', 'san jose de maipo'
          ];

          for (const commune of commonCommunes) {
            const normalizedCommune = normalizeCommuneName(commune);
            // Buscar como palabra completa (no solo substring) para evitar falsos positivos
            const regex = new RegExp(`\\b${normalizedCommune.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');
            if (regex.test(normalizeCommuneName(addressString))) {
              userCommune = normalizedCommune;
              console.log(`üìç Comuna del usuario encontrada en direcci√≥n (b√∫squeda de palabras conocidas): "${commune}" (normalizada: "${userCommune}")`);
              break;
            }
          }
        }
      }

      // PRIORIDAD 2: Si no se pudo extraer del string, intentar geocodificaci√≥n inversa
      if (!userCommune && coords) {
        try {
          const addressDetails = await locationService.reverseGeocode(coords.latitude, coords.longitude);
          // Extraer comuna de los detalles de la direcci√≥n
          // Puede estar en district, subregion, o city dependiendo del proveedor de geocodificaci√≥n
          const extractedCommune = addressDetails?.district || addressDetails?.subregion || addressDetails?.city || null;

          if (extractedCommune) {
            const originalCommune = extractedCommune.trim();
            userCommune = normalizeCommuneName(extractedCommune);
            console.log(`üìç Comuna del usuario detectada (geocodificaci√≥n inversa): "${originalCommune}" (normalizada: "${userCommune}")`);
          } else {
            console.warn('‚ö†Ô∏è No se pudo extraer la comuna de los detalles de geocodificaci√≥n inversa:', addressDetails);
          }
        } catch (error) {
          console.warn('‚ö†Ô∏è No se pudo obtener la comuna mediante geocodificaci√≥n inversa:', error);
        }
      }

      if (!userCommune) {
        console.warn(`‚ö†Ô∏è No se pudo determinar la comuna del usuario desde la direcci√≥n: "${addressString}"`);
      }
    }

    const allMechanics = [];
    const mechanicIds = new Set();

    // Usar el endpoint proveedores_filtrados que filtra por marca del veh√≠culo
    for (const vehicle of userVehicles) {
      if (vehicle.id) {
        try {
          // Usar el endpoint que filtra por marca del veh√≠culo
          const params = {
            vehiculo_id: vehicle.id
          };

          const response = await get('/usuarios/mecanicos-domicilio/proveedores_filtrados/', params);

          // El endpoint devuelve { mecanicos: [...], total: ..., filtros_aplicados: {...} }
          const mechanics = response.mecanicos || [];

          if (Array.isArray(mechanics)) {
            mechanics.forEach(mechanic => {
              if (!mechanicIds.has(mechanic.id)) {
                mechanicIds.add(mechanic.id);
                allMechanics.push(mechanic);
              }
            });
          }
        } catch (error) {
          console.error(`Error obteniendo mec√°nicos para veh√≠culo ${vehicle.id}:`, error);
          // Continuar con el siguiente veh√≠culo si hay error
        }
      }
    }

    // Filtrar por zonas de servicio y calcular distancias
    const filteredMechanics = [];

    if (coords && allMechanics.length > 0) {
      for (const mechanic of allMechanics) {
        let shouldInclude = true;

        // FILTRO 1: REGLA ESTRICTA - Solo mostrar mec√°nicos que tengan zonas de servicio configuradas
        // Si el mec√°nico NO tiene zonas de servicio, NO debe aparecer (regla de funcionamiento)
        if (!mechanic.zonas_servicio || !Array.isArray(mechanic.zonas_servicio) || mechanic.zonas_servicio.length === 0) {
          // Mec√°nico sin zonas configuradas - NO incluir (regla estricta)
          if (filteredMechanics.length < 3) {
            console.log(`‚ùå Mec√°nico ${mechanic.id} (${mechanic.nombre}) NO tiene zonas de servicio configuradas - EXCLUIDO (regla estricta)`);
          }
          shouldInclude = false;
        } else if (userCommune) {
          // Si el usuario tiene comuna detectada, filtrar por zonas de servicio
          // Verificar si el mec√°nico tiene zonas de servicio activas que incluyan la comuna del usuario
          const zonasActivas = mechanic.zonas_servicio.filter(z => z.activa && z.comunas && Array.isArray(z.comunas) && z.comunas.length > 0);

          if (zonasActivas.length > 0) {
            // Solo filtrar si el mec√°nico tiene zonas activas con comunas
            const hasMatchingZone = zonasActivas.some(zona => {
              // Comparaci√≥n normalizada de nombres de comunas
              return zona.comunas.some(communeName => {
                const normalizedZoneCommune = normalizeCommuneName(communeName);
                const matches = normalizedZoneCommune === userCommune;

                // Log detallado de comparaci√≥n solo cuando hay match
                if (matches) {
                  console.log(`   ‚úÖ Match encontrado: "${communeName}" (normalizada: "${normalizedZoneCommune}") === "${userCommune}"`);
                }

                return matches;
              });
            });

            // Si el mec√°nico tiene zonas de servicio activas con comunas, debe tener match
            if (!hasMatchingZone) {
              // Log detallado para debugging (solo el primero para no llenar la consola)
              if (filteredMechanics.length < 3) {
                const zonasComunas = zonasActivas
                  .map(z => {
                    const comunasNormalizadas = z.comunas.map(c => {
                      const norm = normalizeCommuneName(c);
                      return `"${c}" (norm: "${norm}")`;
                    });
                    return `[${comunasNormalizadas.join(', ')}]`;
                  })
                  .join(' | ');

                console.log(`‚ùå Mec√°nico ${mechanic.id} (${mechanic.nombre}) no tiene zona de servicio para comuna del usuario`);
                console.log(`   üìç Comuna usuario (normalizada): "${userCommune}"`);
                console.log(`   üó∫Ô∏è  Zonas activas del mec√°nico (${zonasActivas.length} zonas): ${zonasComunas}`);
              }
              shouldInclude = false;
            } else {
              // Match encontrado, incluir el mec√°nico
              if (filteredMechanics.length < 3) {
                console.log(`‚úÖ Mec√°nico ${mechanic.id} (${mechanic.nombre}) tiene zona de servicio que coincide con comuna del usuario`);
              }
            }
          } else {
            // El mec√°nico tiene zonas configuradas pero ninguna est√° activa o no tiene comunas
            // Como tiene zonas configuradas, lo incluimos (pero con advertencia)
            if (filteredMechanics.length < 3) {
              console.log(`‚ö†Ô∏è Mec√°nico ${mechanic.id} (${mechanic.nombre}) tiene zonas configuradas pero ninguna activa, incluy√©ndolo`);
            }
          }
        } else {
          // Caso: El mec√°nico tiene zonas configuradas pero NO se detect√≥ comuna del usuario
          // Incluirlo porque no podemos verificar el match, pero tiene zonas configuradas
          if (filteredMechanics.length < 3) {
            console.log(`‚ö†Ô∏è No se detect√≥ comuna del usuario, pero mec√°nico ${mechanic.id} (${mechanic.nombre}) tiene zonas configuradas - INCLUIDO (sin verificaci√≥n de match)`);
          }
        }

        // Si pas√≥ el filtro de zonas, calcular distancia
        if (shouldInclude) {
          // Calcular distancia si el mec√°nico tiene ubicaci√≥n
          // Para mec√°nicos a domicilio, usar la direcci√≥n f√≠sica si est√° disponible
          let mechanicLat = null;
          let mechanicLng = null;

          if (mechanic.direccion_fisica && mechanic.direccion_fisica.latitud && mechanic.direccion_fisica.longitud) {
            mechanicLat = parseFloat(mechanic.direccion_fisica.latitud);
            mechanicLng = parseFloat(mechanic.direccion_fisica.longitud);
          } else if (mechanic.ubicacion) {
            // Si tiene ubicaci√≥n GeoDjango
            if (typeof mechanic.ubicacion === 'object' && mechanic.ubicacion.coordinates) {
              mechanicLng = parseFloat(mechanic.ubicacion.coordinates[0]);
              mechanicLat = parseFloat(mechanic.ubicacion.coordinates[1]);
            }
          }

          if (mechanicLat && mechanicLng && !isNaN(mechanicLat) && !isNaN(mechanicLng)) {
            // Calcular distancia (Haversine)
            const distance = calculateDistance(
              coords.latitude,
              coords.longitude,
              mechanicLat,
              mechanicLng
            );

            // Asignar distancia en m√∫ltiples campos para compatibilidad con diferentes componentes
            mechanic.distancia_km = distance;
            mechanic.distance = distance; // Campo usado por NearbyMecanicoCard
            mechanic.distancia = distance; // Campo alternativo

            console.log(`üìè Distancia calculada para mec√°nico ${mechanic.id} (${mechanic.nombre}): ${distance.toFixed(2)}km`);

            // FILTRO 2: Verificar radio de cobertura del mec√°nico
            const radioCobertura = mechanic.radio_cobertura || mechanic.radioCobertura || null;

            if (radioCobertura && typeof radioCobertura === 'number' && radioCobertura > 0) {
              if (distance > radioCobertura) {
                console.log(`‚ùå Mec√°nico ${mechanic.id} (${mechanic.nombre}) est√° fuera del radio de cobertura: ${distance.toFixed(2)}km > ${radioCobertura}km`);
                shouldInclude = false;
              }
            }
          } else {
            // Si no tiene coordenadas, usar distancia del backend si est√° disponible
            if (mechanic.distance !== undefined && mechanic.distance !== null) {
              const backendDistance = typeof mechanic.distance === 'number' ? mechanic.distance : parseFloat(mechanic.distance);
              mechanic.distancia_km = backendDistance;
              mechanic.distance = backendDistance;
              mechanic.distancia = backendDistance;
              console.log(`üìè Usando distancia del backend para mec√°nico ${mechanic.id}: ${backendDistance.toFixed(2)}km`);
            } else {
              console.warn(`‚ö†Ô∏è Mec√°nico ${mechanic.id} (${mechanic.nombre}) no tiene coordenadas ni distancia del backend`);
            }
          }

          if (shouldInclude) {
            filteredMechanics.push(mechanic);
          }
        }
      }

      // Ordenar por distancia
      filteredMechanics.sort((a, b) => {
        const distA = a.distancia_km || Infinity;
        const distB = b.distancia_km || Infinity;
        return distA - distB;
      });

      console.log(`‚úÖ Mec√°nicos filtrados: ${filteredMechanics.length} de ${allMechanics.length} (filtrados por zonas de servicio y radio de cobertura)`);
      console.log(`üìä Resumen de filtrado:`);
      console.log(`   - Total mec√°nicos obtenidos: ${allMechanics.length}`);
      console.log(`   - Comuna del usuario: ${userCommune || 'NO DETECTADA'}`);
      console.log(`   - Mec√°nicos despu√©s de filtrado: ${filteredMechanics.length}`);
      console.log(`   - Coordenadas usuario: ${coords ? `${coords.latitude.toFixed(6)}, ${coords.longitude.toFixed(6)}` : 'NO DISPONIBLES'}`);

      // Verificar que las distancias se calcularon correctamente
      const mecanicosConDistancia = filteredMechanics.filter(m => m.distance !== undefined && m.distance !== null).length;
      console.log(`   - Mec√°nicos con distancia calculada: ${mecanicosConDistancia} de ${filteredMechanics.length}`);

      // Mostrar distancias de los primeros 3 mec√°nicos para verificaci√≥n
      if (filteredMechanics.length > 0) {
        const primerosMecanicos = filteredMechanics.slice(0, 3);
        primerosMecanicos.forEach(m => {
          console.log(`   - ${m.nombre}: distancia = ${m.distance !== undefined ? m.distance.toFixed(2) + 'km' : 'NO CALCULADA'}`);
        });
      }

      // Log detallado de mec√°nicos excluidos
      const excludedCount = allMechanics.length - filteredMechanics.length;
      if (excludedCount > 0) {
        console.log(`   - Mec√°nicos excluidos: ${excludedCount}`);
      }
    } else {
      // Si no hay coordenadas, aplicar el mismo filtro de zonas de servicio
      // pero sin calcular distancias ni verificar radio de cobertura
      for (const mechanic of allMechanics) {
        let shouldInclude = true;

        // REGLA ESTRICTA: Solo incluir mec√°nicos con zonas de servicio configuradas
        if (!mechanic.zonas_servicio || !Array.isArray(mechanic.zonas_servicio) || mechanic.zonas_servicio.length === 0) {
          // Sin zonas configuradas - EXCLUIR (regla estricta)
          shouldInclude = false;
        } else if (userCommune) {
          // Si hay comuna, verificar match con zonas
          const zonasActivas = mechanic.zonas_servicio.filter(z => z.activa && z.comunas && Array.isArray(z.comunas) && z.comunas.length > 0);

          if (zonasActivas.length > 0) {
            const hasMatchingZone = zonasActivas.some(zona => {
              return zona.comunas.some(communeName => {
                const normalizedZoneCommune = normalizeCommuneName(communeName);
                return normalizedZoneCommune === userCommune;
              });
            });

            if (!hasMatchingZone) {
              shouldInclude = false;
            }
          }
        }
        // Si no hay comuna pero el mec√°nico tiene zonas, incluirlo (mejor que no mostrar nada)

        if (shouldInclude) {
          filteredMechanics.push(mechanic);
        }
      }
    }

    return filteredMechanics;
  } catch (error) {
    console.error('Error obteniendo mec√°nicos para veh√≠culos del usuario:', error);
    return [];
  }
};

/**
 * Obtiene talleres cercanos con informaci√≥n de distancia
 * @param {string|Object} address - Direcci√≥n del usuario (puede ser string o objeto)
 * @param {number} radius - Radio de b√∫squeda en km
 * @returns {Promise<Array>} Lista de talleres cercanos
 */
export const getTalleresRealmenteCercanos = async (address, radius = 10) => {
  try {
    if (!address) {
      console.log('No se proporcion√≥ direcci√≥n para buscar talleres cercanos');
      return [];
    }

    // Extraer la direcci√≥n como string si es un objeto
    let addressString = address;
    if (typeof address === 'object' && address.direccion) {
      addressString = address.direccion;
    } else if (typeof address === 'object' && address.address) {
      addressString = address.address;
    }

    // Geocodificar la direcci√≥n
    const coords = await locationService.geocodeAddress(addressString);
    if (!coords) {
      console.log('No se pudo geocodificar la direcci√≥n');
      return [];
    }

    const response = await get('/usuarios/talleres/cerca/', {
      lat: coords.latitude,
      lng: coords.longitude,
      dist: radius,
      ordenar_por: 'distancia'
    });

    return response.results || response || [];
  } catch (error) {
    console.error('Error obteniendo talleres cercanos:', error);
    return [];
  }
};

/**
 * Obtiene mec√°nicos cercanos con informaci√≥n de distancia
 * @param {string|Object} address - Direcci√≥n del usuario (puede ser string o objeto)
 * @param {number} radius - Radio de b√∫squeda en km
 * @returns {Promise<Array>} Lista de mec√°nicos cercanos
 */
export const getMecanicosRealmenteCercanos = async (address, radius = 10) => {
  try {
    if (!address) {
      console.log('No se proporcion√≥ direcci√≥n para buscar mec√°nicos cercanos');
      return [];
    }

    // Extraer la direcci√≥n como string si es un objeto
    let addressString = address;
    if (typeof address === 'object' && address.direccion) {
      addressString = address.direccion;
    } else if (typeof address === 'object' && address.address) {
      addressString = address.address;
    }

    // Geocodificar la direcci√≥n
    const coords = await locationService.geocodeAddress(addressString);
    if (!coords) {
      console.log('No se pudo geocodificar la direcci√≥n');
      return [];
    }

    const response = await get('/usuarios/mecanicos-domicilio/cerca/', {
      lat: coords.latitude,
      lng: coords.longitude,
      dist: radius,
      ordenar_por: 'distancia'
    });

    return response.results || response || [];
  } catch (error) {
    console.error('Error obteniendo mec√°nicos cercanos:', error);
    return [];
  }
};

/**
 * Obtiene talleres cercanos por coordenadas
 * @param {number} lat - Latitud
 * @param {number} lng - Longitud
 * @param {number} radius - Radio de b√∫squeda en km
 * @returns {Promise<Array>} Lista de talleres cercanos
 */
export const getNearbyWorkshops = async (lat, lng, radius = 10) => {
  try {
    const response = await get('/usuarios/talleres/cerca/', {
      lat: lat,
      lng: lng,
      dist: radius,
      ordenar_por: 'distancia'
    });

    return response.results || response || [];
  } catch (error) {
    console.error('Error obteniendo talleres cercanos por coordenadas:', error);
    return [];
  }
};

/**
 * Obtiene mec√°nicos cercanos por coordenadas
 * @param {number} lat - Latitud
 * @param {number} lng - Longitud
 * @param {number} radius - Radio de b√∫squeda en km
 * @returns {Promise<Array>} Lista de mec√°nicos cercanos
 */
export const getNearbyMechanics = async (lat, lng, radius = 10) => {
  try {
    const response = await get('/usuarios/mecanicos-domicilio/cerca/', {
      lat: lat,
      lng: lng,
      dist: radius,
      ordenar_por: 'distancia'
    });

    return response.results || response || [];
  } catch (error) {
    console.error('Error obteniendo mec√°nicos cercanos por coordenadas:', error);
    return [];
  }
};

/**
 * Obtiene talleres por modelo de veh√≠culo
 * @param {number} modeloId - ID del modelo
 * @returns {Promise<Array>} Lista de talleres compatibles
 */
export const getWorkshopsByModelo = async (modeloId) => {
  try {
    const response = await get('/usuarios/talleres/', {
      modelo: modeloId,
      especialidades: true
    });

    return response.results || response || [];
  } catch (error) {
    console.error('Error obteniendo talleres por modelo:', error);
    return [];
  }
};

/**
 * Obtiene mec√°nicos por modelo de veh√≠culo
 * @param {number} modeloId - ID del modelo
 * @returns {Promise<Array>} Lista de mec√°nicos compatibles
 */
export const getMechanicsByModelo = async (modeloId) => {
  try {
    const response = await get('/usuarios/mecanicos-domicilio/', {
      modelo: modeloId,
      especialidades: true
    });

    return response.results || response || [];
  } catch (error) {
    console.error('Error obteniendo mec√°nicos por modelo:', error);
    return [];
  }
};

/**
 * Obtiene todos los talleres disponibles
 * @returns {Promise<Array>} Lista de talleres
 */
export const getTalleres = async () => {
  try {
    const response = await get('/usuarios/talleres/');
    return response.results || response || [];
  } catch (error) {
    console.error('Error obteniendo talleres:', error);
    return [];
  }
};

/**
 * Obtiene todos los mec√°nicos disponibles
 * @returns {Promise<Array>} Lista de mec√°nicos
 */
export const getMecanicos = async () => {
  try {
    const response = await get('/usuarios/mecanicos-domicilio/');
    return response.results || response || [];
  } catch (error) {
    console.error('Error obteniendo mec√°nicos:', error);
    return [];
  }
};

/**
 * Obtiene informaci√≥n detallada de un taller
 * @param {number} tallerId - ID del taller
 * @returns {Promise<Object>} Informaci√≥n del taller
 */
export const getTallerDetalle = async (tallerId) => {
  try {
    const response = await get(`/usuarios/talleres/${tallerId}/`);
    return response;
  } catch (error) {
    console.error('Error obteniendo detalle del taller:', error);
    return null;
  }
};

/**
 * Obtiene informaci√≥n detallada de un mec√°nico
 * @param {number} mecanicoId - ID del mec√°nico
 * @returns {Promise<Object>} Informaci√≥n del mec√°nico
 */
export const getMecanicoDetalle = async (mecanicoId) => {
  try {
    const response = await get(`/usuarios/mecanicos-domicilio/${mecanicoId}/`);
    return response;
  } catch (error) {
    console.error('Error obteniendo detalle del mec√°nico:', error);
    return null;
  }
};

/**
 * Busca proveedores por t√©rmino de b√∫squeda
 * @param {string} termino - T√©rmino de b√∫squeda
 * @param {string} tipo - 'taller' o 'mecanico' o 'todos'
 * @returns {Promise<Object>} Objeto con talleres y mec√°nicos encontrados
 */
export const buscarProveedores = async (termino, tipo = 'todos') => {
  try {
    let talleres = [];
    let mecanicos = [];

    if (tipo === 'todos' || tipo === 'taller') {
      const talleresResponse = await get('/usuarios/talleres/', { search: termino });
      talleres = talleresResponse.results || talleresResponse || [];
    }

    if (tipo === 'todos' || tipo === 'mecanico') {
      const mecanicosResponse = await get('/usuarios/mecanicos-domicilio/', { search: termino });
      mecanicos = mecanicosResponse.results || mecanicosResponse || [];
    }

    return { talleres, mecanicos };
  } catch (error) {
    console.error('Error buscando proveedores:', error);
    return { talleres: [], mecanicos: [] };
  }
};

export default {
  getProvidersByVehiculo,
  getProvidersByVehiculoAndService,
  getWorkshopsForUserVehicles,
  getMechanicsForUserVehicles,
  getTalleresRealmenteCercanos,
  getMecanicosRealmenteCercanos,
  getNearbyWorkshops,
  getNearbyMechanics,
  getWorkshopsByModelo,
  getMechanicsByModelo,
  getTalleres,
  getMecanicos,
  getTallerDetalle,
  getMecanicoDetalle,
  buscarProveedores
}; 